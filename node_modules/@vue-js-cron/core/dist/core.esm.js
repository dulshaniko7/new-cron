import Mustache from 'mustache';

function range$1(start, end, step=1) {
    let r = [];
    for(let i = start; i <= end; i+=step){
        r.push(i);
    }
    return r
}

class Range {
    constructor(start, end, step=1){
        this.start = start;
        this.end = end;
        this.step = step;

        return new Proxy(this, {
            get: function (target, prop) {
                let i = (typeof prop === 'string') ? parseInt(prop) : prop;
                if(typeof i == 'number' && i >= 0 && i <= target.length){
                    return target.start+target.step*i
                }
                return Reflect.get(...arguments)
            }
        })
    }

    get length(){
        return parseInt((this.end-this.start)/this.step)+1
    }

    [Symbol.iterator]() {
        var index = -1;
        return {
            next: () => {
                return { value: this[++index], done: !(this[index+1] !== undefined) }
            }
        }
    }
}

function getValue(params, key){
    let keys = key.split('.');
    let value = params;
    for(let k of keys){
        value = value[k];
    }
    return value
}

function format(str, params){
    let re = /\{\{\S+\}\}/gm;
    let m;
    while((m = re.exec(str)) !== null){
        let key = m[0].substring(2, m[0].length-2);
        let value = getValue(params, key);
        str = str.substr(0, m.index) + value + str.substr(m.index+m[0].length);
        re.lastIndex = m.index;
    }
    return str    
}

/**
 * type definition
 * @name toText
 * @function
 * @param {number} value
 * @returns {string}
*/

/**
 * generate items for fields
 * @param {number} min first value
 * @param {number} max last value
 * @param {toText} genText returns a string representation of value
 * @param {toText} genAltText returns an alternative string representation of value
 * @returns {Array<{value:number, text:string, alt:string}>} array of items
 */
function genItems$1(min, max, genText=(value) => {return value+''}, genAltText=(value) => {return value+''}){
    let res = [];
    for(let i of new Range(min, max)){
        let item = {};
        item.text = genText(i);
        item.alt = genAltText(i);
        item.value = i;
        res.push(item);
    }
    return res
}

/**
 * pads numbers
 * @param {number} n number to pad 
 * @param {number} width
 * @example
 * //returns "001"
 * util.pad(1,3) 
 * @returns {string} the padded number
 */
function pad$1(n, width){
    n = n+'';
    return (n.length < width) ? new Array(width - n.length).fill('0').join('') + n : n;
}

/**
 * determines whether the passed value is an object
 * @param {any} value 
 * @returns {Boolean} true if value is an object, otherwise false
 */
function isObject(value){
    return (value && typeof value == 'object' && !Array.isArray(value))
}

/**
 * copies (deep copy) all properties from each source to target 
 * @param {object} target 
 * @param  {...object} sources 
 * @returns {object} target
 */
function deepMerge(target, ...sources){
    if(!isObject(target) || sources.length == 0) return
    let source = sources.shift();

    if(isObject(source)){
        for(let [key, value] of Object.entries(source)){
            if(isObject(value)){
                if(!isObject(target[key])){
                    target[key] = {};
                }
                deepMerge(target[key], source[key]);
            }
            
            else {
                target[key] = source[key];
            }
        }
    }

    if(sources.length > 0) deepMerge(target, sources);
    return target
}


function traverse$1(obj, ...keys){
    if(keys.length == 0)
        return obj
        
    for(let key of keys[0]){
        if(obj.hasOwnProperty(key)){
            let res = traverse$1(obj[key], ...keys.slice(1));
            if(res !== undefined){
                return res
            }
        }
    }
    return
}

var util = {
    range: range$1,
    Range,
    format,
    genItems: genItems$1,
    pad: pad$1,
    deepMerge,
    isObject,
    traverse: traverse$1
};

var en = {
    eachPeriod: {   
        eachField: {
            empty: 'every {{field.id}}',
            value: '{{value.text}}',
            range: '{{start.text}}-{{end.text}}',
            everyX: 'every {{every.value}}'
        },
        monthField: {
            prefix: 'in',
            value: '{{value.alt}}',
            range: '{{start.alt}}-{{end.alt}}',
        },
        dayField: {
            prefix: 'on'
        },
        dayOfWeekField: {
            prefix: 'on',
            empty: 'every day of the week',
            value: '{{value.alt}}',
            range: '{{start.alt}}-{{end.alt}}',
        },
        hourField: {
            prefix: 'at'
        },
        minuteField: {
            prefix: ':'
        }
    },
    hourPeriod: {
        minuteField: {
            prefix: 'at',
            suffix: 'minute(s)',
            empty: 'every'
        }
    },
    monthPeriod: {
        dayOfWeekField: {
            prefix: 'and'
        }
    },
    yearPeriod: {
        dayOfWeekField: {
            prefix: 'and'
        }
    },
    periodPrefix: 'Every',
    periodSuffix: ''
};

const {genItems, pad, traverse} = util;

const locales = {
    en: en
};

/**
 * 
 * @param {string} locale=en 
 * @returns {object} object with all strings in the requested language  
 */
function getLocale$1(locale){
    if(locales.hasOwnProperty(locale)){
        return locales[locale]
    }
    else {
        return locales['en']
    }
}

/**
 * 
 * @param {string} locale 
 * @returns {object} items for minute, hour, day, month and day of week
 */
function defaultItems$1(locale){
    return {
        minuteItems: genItems(0, 59, (value) => pad(value, 2)),
        hourItems: genItems(0, 23, (value) => pad(value, 2)),
        dayItems: genItems(1, 31),
        monthItems: genItems(1, 12, (value) => {
            return new Date(2021, value-1, 1).toLocaleDateString(locale, {month: 'long'})
        }, (value) => {
            return new Date(2021, value-1, 1).toLocaleDateString(locale, {month: 'short'})
        }),
        dayOfWeekItems: genItems(0, 6, (value) => {
            let date = new Date(2021, 0, 3+value); //first sunday in 2021
            return date.toLocaleDateString(locale, {weekday: 'long'})
        }, (value) => {
            let date = new Date(2021, 0, 3+value); //first sunday in 2021
            return date.toLocaleDateString(locale, {weekday: 'short'})
        })
    }
}

var locale = {
    getLocaleStr: (locale, periodId, fieldId, localeKey) => {
        return traverse(locale, [periodId+'Period', 'eachPeriod'], [fieldId+'Field', 'eachField'], [localeKey]) || ''
    },

    getPrefix: (locale, periodId, fieldId) => {
        return traverse(locale, [periodId+'Period', 'eachPeriod'], [fieldId+'Field', 'eachField'], ['prefix']) || ''
    },

    getSuffix: (locale, periodId, fieldId) => {
        return traverse(locale, [periodId+'Period', 'eachPeriod'], [fieldId+'Field', 'eachField'], ['suffix']) || ''
    },
    
    defaultItems: defaultItems$1,
    getLocale: getLocale$1
};

const {getLocaleStr} = locale;


class Field$1 {

    /**
     * 
     * @param {String} name 
     * @param {Array} items 
     */
    constructor(id, items){
        this.id = id;
        this.items = items;

        this.itemMap = this.items.reduce((acc, item) => {
            acc[item.value] = item;
            return acc
        }, {});
    }

    get min(){
        return this.items[0].value
    }

    get max(){
        return this.items[this.items.length-1].value
    }

    getItem(value){
        return this.itemMap[value]
    }

}

class CronColumn{

    /**
     * 
     * @param {Field} field 
     */
    constructor(field){
        this.field = field;
    }

    get localeKey(){
        return 'value'
    }

    get localeParams(){
        return {}
    }

    get value(){
        return '*'
    }

    getText(locale, periodId){
        let str = getLocaleStr(locale, periodId, this.field.id, this.localeKey);
        let params = this.populate(this.localeParams);
        return Mustache.render(str, params)
    }

    getItem(value){
        return this.field.getItem(value)
    }

    populate(obj){
        for(const [key, itemValue] of Object.entries(obj)){
            obj[key] = this.getItem(itemValue);
        }
        obj.field = this.field;
        return obj
    }
}

class AnyColumn$1 extends CronColumn {
    
    get localeKey(){
        return 'empty'
    }
    
    get value(){
        return '*'
    }

}

class RangeColumn$1 extends CronColumn {
    
    constructor(field, start, end){
        super(field);
        this.start = start;
        this.end = end;
    }

    get localeKey(){
        return 'range'
    }

    get localeParams(){
        return {
            start: this.start,
            end: this.end
        }
    }
    
    get value(){
        return `${this.start}-${this.end}`
    }

}

class EveryColumn$1 extends CronColumn {

    constructor(field, every){
        super(field);
        this.every = every;
    }

    get localeKey(){
        return 'everyX'
    }

    get localeParams(){
        return {
            every: this.every,
        }
    }

    get value(){
        return `*/${this.every}`
    }

}

class ValueColumn$2 extends CronColumn {

    constructor(field, value){
        super(field);
        this.v = value;
    }

    get localeKey(){
        return 'value'
    }

    get localeParams(){
        return {
            value: this.v,
        }
    }

    get value(){
        return ''+this.v
    }

}

class CombinedColumn$2 extends CronColumn {

    constructor(field, columns=[]){
        super(field);
        this.columns = columns;
    }

    addColumn(cronColumn){
        this.columns.push(cronColumn);
    }

    get value(){
        return this.columns.map((c) => c.value).join(',')
    }

    getText(locale, periodId){
        return this.columns.map((c) => c.getText(locale, periodId)).join(',')
    }

}

var types = {
    Field: Field$1,
    AnyColumn: AnyColumn$1,
    RangeColumn: RangeColumn$1,
    ValueColumn: ValueColumn$2,
    EveryColumn: EveryColumn$1,
    CombinedColumn: CombinedColumn$2,
};

const { AnyColumn } = types;

function strToArray$4(str){
    if(str != '*'){
        return null
    }
    return []
}

function arrayToStr$4(arr, field){
    let {items} = field;

    if(arr.length == 0){
        return new AnyColumn(field)
    }
    if(arr.length != items.length){
        return null
    }

    for(let item of items){
        if(!arr.includes(item.value)){
            return null
        }
    }
    return new AnyColumn(field)
}

var any = {
    strToArray: strToArray$4,
    arrayToStr: arrayToStr$4
};

// */x
const { EveryColumn } = types;

let re$1 = /^\*\/\d+$/;

function strToArray$3(str, {min, max}){
    if(!re$1.test(str)){
        return null
    }
    
    let [, everyStr] = str.split('/');
    let every = parseInt(everyStr);

    let start = every * parseInt(min/every);
    let res = [];
    for(let i = start; i <= max; i+=every){
        if(i >= min){
            res.push(i);
        }
    }
    return res.length > 0 ? res : null
}

function arrayToStr$3(arr, field){
    let {min, max} = field;

    if(arr.length < 3){
        return null
    }

    let step = arr[1] - arr[0];
    if(step <= 1){
        return null
    }

    let first = (min%step == 0) ? min : (parseInt(min/step)+1)*step;
    if(arr.length != parseInt((max-first)/step)+1){
        return null
    }

    for(let value of arr){
        if(value%step != 0){
            return null
        }
    }

    return new EveryColumn(field, step)
}

var every = {
    strToArray: strToArray$3,
    arrayToStr: arrayToStr$3
};

let { RangeColumn, CombinedColumn: CombinedColumn$1, ValueColumn: ValueColumn$1 } = types;
// x-y

let re = /^\d+-\d+$/;

function strToArray$2(str, {min, max}){
    if(!re.test(str)){
        return null
    }

    let range = str.split('-');
    let start = parseInt(range[0]);
    let end = parseInt(range[1]);

    if(start > end || start < min || end > max){
        return null
    }

    return util.range(start, end)
}

function arrayToStr$2(arr, field){
    let {min, max} = field;
    
    if(arr.length <= 1){
        return null
    }

    let minValue = arr[0];
    let maxValue = arr[arr.length-1];

    if(minValue < min){
        return null
    }
    if(maxValue > max){
        return null
    }

    let ranges = [];
    let start = 0;
    for(let i = 0; i < arr.length; i++){
        if(arr[i+1] === undefined || arr[i+1] - arr[i] > 1){
            if(i == start){
                ranges.push(new ValueColumn$1(field, arr[start]));
            }
            else {
                ranges.push(new RangeColumn(field, arr[start], arr[i]));
            }
            start = i+1;
        }
    }

    return new CombinedColumn$1(field, ranges)
}

var range = {
    strToArray: strToArray$2,
    arrayToStr: arrayToStr$2
};

// x
const { ValueColumn, CombinedColumn } = types;

function strToArray$1(str, {min, max}){
    let number = parseInt(str);
    return (String(number) == str && number >= min && number <= max) ? [number] : null
}

function arrayToStr$1(arr, field){
    let {min, max} = field;

    if(Math.min(arr) < min){
        return null
    }
    if(Math.max(arr) > max){
        return null
    }

    let values = arr.map((x) => {return new ValueColumn(field, x)});
    return new CombinedColumn(field, values)
}

var value = {
    strToArray: strToArray$1,
    arrayToStr: arrayToStr$1
};

// x,y,z

let fieldTypes = [any, every, range, value];

function strToArray(str, field){
    let fields = str.split(',');
    let res = [];
    for(let f of fields){
        if(f == '*'){
            return []
        }

        let values = null;
        for(let fieldType of fieldTypes){
            values = fieldType.strToArray(f, field);
            if(values !== null){
                break
            }
        }
        if(values === null){
            return null
        }
        res.push(...values);
    }
    return Array.from(new Set(res))
}

function arrayToStr(arr, field){
    for(let fieldType of fieldTypes){
        let value = fieldType.arrayToStr(arr, field);
        if(value){
            return value
        }
    }
    return null
}

var multiple = {
    strToArray,
    arrayToStr
};

const {getLocale, defaultItems, getSuffix, getPrefix} = locale;
const {Field} = types;

var script = {
    name: "VueCronCore",
    props: {
        value: {
            type: String,
            default: '* * * * *'
        },
        locale: {
            type: String,
            default: 'en'
        },
        fields: {
            type: Array,
            default: function() {

                let items = defaultItems(this.locale);

                return [
                    {id: 'minute', items: items.minuteItems},
                    {id: 'hour', items: items.hourItems},
                    {id: 'day', items: items.dayItems},
                    {id: 'month', items: items.monthItems},
                    {id: 'dayOfWeek', items: items.dayOfWeekItems},
                ]
            }
        },
        periods: {
            type: Array,
            default: () => {
                return [
                    { id: 'minute', text: 'Minute', value: [] },
                    { id: 'hour', text: 'Hour', value: ['minute'] },
                    { id: 'day', text: 'Day', value: ['hour', 'minute'] },
                    { id: 'week', text: 'Week', value: ['dayOfWeek', 'hour', 'minute'] },
                    { id: 'month', text: 'Month', value: ['day', 'dayOfWeek', 'hour', 'minute'] },
                    { id: 'year', text: 'Year', value: ['month', 'day', 'dayOfWeek', 'hour', 'minute'] },
                ]
            }
        },
        customLocale: {
            type: Object,
            default: function() {
                return getLocale(this.locale)
            }
        },
        mergeLocale: {
            type: Boolean,
            default: true
        }
    },
    data(){

        let selected = {};
        for(let field of this.fields){
            selected[field.id] = [];
        }

        return {
            selected: selected,
            error: '',
            selectedPeriod: this.periods[this.periods.length-1]
        }
    },

    computed: {
        splitValue(){
            return this.value.split(' ')
        },
        fieldIndex(){
            return this.fields.reduce((acc, f, i) => {
                acc[f.id] = i;
                return acc
            }, {})
        },
        periodIndex(){
            return this.periods.reduce((acc, p, i) => {
                acc[p.id] = i;
                return acc
            })
        },
        computedFields(){
            return this.fields.map((f) => new Field(f.id, f.items))
        },
        filteredFields(){
            return this.selectedPeriod.value.map((fieldId) => {
                let i = this.fieldIndex[fieldId];
                return this.computedFields[i]
            })
        },
        computedLocale(){
            if(this.mergeLocale){
                let defaultLocale = getLocale(this.locale);
                return util.deepMerge(defaultLocale, this.customLocale)
            }
            else {
                return this.customLocale
            }
        }
    },
    
    watch: {
        value: {
            handler: function(value){
                this.cronToSelected(value);
            },
            immediate: true
        },
        selected: {
            handler: function(selected){
                this.selectedToCron(selected);
            },
            deep:true
        },
        selectedPeriod: {
            handler: function(){
                this.selectedToCron(this.selected);
            },
        },
        error: {
            handler: function(error){
                this.$emit('error', error);
            }
        }
    },

    render(){

        if(!this.$scopedSlots.default){
            return
        }

        let fieldProps = [];
        for(let field of this.filteredFields){
            let i = this.fieldIndex[field.id];
            let values = this.selected[field.id];

            let attrs = {
                value: values,
            };
            let events = {
                input: ((fieldId) => (evt) => {
                    const selected = Array.from(evt).sort((a, b) => { return a > b ? 1 : -1 });
                    this.selected[fieldId] = selected;
                })(field.id)
            };

            fieldProps.push({
                ...field,
                cron: this.splitValue[i],
                selectedStr: multiple.arrayToStr(values, field).getText(this.computedLocale, this.selectedPeriod.id),
                events,
                attrs,
                prefix: getPrefix(this.computedLocale, this.selectedPeriod.id, field.id),
                suffix: getSuffix(this.computedLocale, this.selectedPeriod.id, field.id)
            });
        }

        return this.$scopedSlots.default({
            error: this.error,
            fields: fieldProps,

            period:{
                attrs:{
                    value: this.selectedPeriod.id
                },
                events:{
                    input: (periodId) => {
                        let i = this.periodIndex[periodId] || 0;
                        this.selectedPeriod = this.periods[i];
                    }
                },
                items: this.periods,
                prefix: this.computedLocale.periodPrefix,
                suffix: this.computedLocale.periodSuffix
            }
        })
    },

    methods: {
        defaultValue(){
            return new Array(this.fields.length).fill('*').join(' ')
        },
        cronToSelected(value){
            if(!value){
                this.$emit('input', this.defaultValue());
                return
            }

            if(this.splitValue.length != this.fields.length){
                this.error = 'invalid pattern';
                return
            }
            
            for(var i = 0; i < this.splitValue.length; i++){
                let field = this.computedFields[i];
                if(!this.selectedPeriod.value.includes(field.id)){
                    continue
                }

                let array = multiple.strToArray(this.splitValue[i], field);
                if(array === null){
                    this.error = 'invalid pattern';
                    return
                }
                this.selected[field.id] = array;
            }

            this.error = '';
        },
        selectedToCron(selected){

            let strings = [];
            for(let field of this.computedFields){
                if(!this.selectedPeriod.value.includes(field.id)){
                    strings.push('*');
                    continue
                }
                let array = selected[field.id];
                let str = multiple.arrayToStr(array, field);
                if(str === null){
                    this.error = 'invalid selection';
                    return
                }
                strings.push(str.value);
            }
            this.error = '';
            this.$emit('input', strings.join(' '));
        }
    }
};

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
        createInjectorSSR = createInjector;
        createInjector = shadowMode;
        shadowMode = false;
    }
    // Vue.extend constructor export interop.
    const options = typeof script === 'function' ? script.options : script;
    // render functions
    if (template && template.render) {
        options.render = template.render;
        options.staticRenderFns = template.staticRenderFns;
        options._compiled = true;
        // functional template
        if (isFunctionalTemplate) {
            options.functional = true;
        }
    }
    // scopedId
    if (scopeId) {
        options._scopeId = scopeId;
    }
    let hook;
    if (moduleIdentifier) {
        // server build
        hook = function (context) {
            // 2.3 injection
            context =
                context || // cached call
                    (this.$vnode && this.$vnode.ssrContext) || // stateful
                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
            // 2.2 with runInNewContext: true
            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                context = __VUE_SSR_CONTEXT__;
            }
            // inject component styles
            if (style) {
                style.call(this, createInjectorSSR(context));
            }
            // register component module identifier for async chunk inference
            if (context && context._registeredComponents) {
                context._registeredComponents.add(moduleIdentifier);
            }
        };
        // used by ssr in case component is cached and beforeCreate
        // never gets called
        options._ssrRegister = hook;
    }
    else if (style) {
        hook = shadowMode
            ? function (context) {
                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
            }
            : function (context) {
                style.call(this, createInjector(context));
            };
    }
    if (hook) {
        if (options.functional) {
            // register for functional component in vue file
            const originalRender = options.render;
            options.render = function renderWithStyleInjection(h, context) {
                hook.call(context);
                return originalRender(h, context);
            };
        }
        else {
            // inject component registration as beforeCreate hook
            const existing = options.beforeCreate;
            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
    }
    return script;
}

/* script */
const __vue_script__ = script;

/* template */

  /* style */
  const __vue_inject_styles__ = undefined;
  /* scoped */
  const __vue_scope_id__ = undefined;
  /* module identifier */
  const __vue_module_identifier__ = undefined;
  /* functional template */
  const __vue_is_functional_template__ = undefined;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__ = /*#__PURE__*/normalizeComponent(
    {},
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    false,
    undefined,
    undefined,
    undefined
  );

// Import vue component

// Declare install function executed by Vue.use()
function install(Vue) {
	if (install.installed) return;
	install.installed = true;
	Vue.component('CronCore', __vue_component__);
}

// Create module definition for Vue.use()
const plugin = {
	install,
	component: __vue_component__,
	util,
	locale
};

export { plugin as default, install };
