(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@vue-js-cron/core'), require('@vue-js-cron/core/src/fields/multiple')) :
  typeof define === 'function' && define.amd ? define(['exports', '@vue-js-cron/core', '@vue-js-cron/core/src/fields/multiple'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.light = {}, global.CronCore));
})(this, (function (exports, CronCore) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var CronCore__default = /*#__PURE__*/_interopDefaultLegacy(CronCore);

  //

  var script$1 = {
    inheritAttrs: false,
    name: 'CustomSelect',
    props:{
      multiple: {
        type: Boolean,
        default: false
      },
      value: {
        type: String | Array | Object,
        default(){
          return this.multiple ? [] : null
        },
      },
      items: {
        type: Array,
        default: () => []
      },
      returnObject: {
        type: Boolean,
        default: false
      },
      itemText: {
        type: String,
        default: 'text'
      },
      itemValue: {
        type: String,
        default: 'value'
      },
      cols: {
        type: Number,
        default: 1
      },
      width: {
        type: String,
        default: 'unset'
      }
    },
    data(){
      return {
        menu: false
      }
    },
    computed: {
      listStyle() {
        return {
          display: (this.menu) ? 'inline-block' : 'none',
          minWidth: '5em',
          width: this.width
        }
      },
      listItemStyle() {
        return {
          width: 100/this.cols + '%'
        }
      },
      _value(){
        return (this.multiple) ? this.value : [this.value]
      },
      selectedItems(){
        return this.items.filter((item) => {
          for(let value of this._value){
            if(this.returnObject){
              if (value == item) return true
            }
            else {
              if (value == item[this.itemValue]) return true
            }
          }
          return false
        })
      },
      selectedStr(){
        return this.selectedItems.map((item) => item[this.itemText]).join(',')
      }
    },
    methods: {
      menuEvtListener(evt){
        this.menu = false;
        document.removeEventListener('click', this.menuEvtListener);
      },
      toggleMenu(){
        this.menu = !this.menu;

        if(this.menu){
          setTimeout(() => {
            document.addEventListener('click', this.menuEvtListener);
          }, 1);
        }
        else {
          document.removeEventListener('click', this.menuEvtListener);
        }
      },
      select(item){
        if(this.multiple){
          let value = this.selectedItems.slice();
          let i = this.selectedItems.indexOf(item);
          //deselect
          if(i >= 0){
            value.splice(i,1);
          }
          //select
          else {
            value.push(item);
          }
          this.$emit('input', (this.returnObject) ? value : value.map((item) => item[this.itemValue]));
        }
        else {
          this.$emit('input', (this.returnObject) ? item : item[this.itemValue]);
        }
      }
    }
  };

  function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
      if (typeof shadowMode !== 'boolean') {
          createInjectorSSR = createInjector;
          createInjector = shadowMode;
          shadowMode = false;
      }
      // Vue.extend constructor export interop.
      const options = typeof script === 'function' ? script.options : script;
      // render functions
      if (template && template.render) {
          options.render = template.render;
          options.staticRenderFns = template.staticRenderFns;
          options._compiled = true;
          // functional template
          if (isFunctionalTemplate) {
              options.functional = true;
          }
      }
      // scopedId
      if (scopeId) {
          options._scopeId = scopeId;
      }
      let hook;
      if (moduleIdentifier) {
          // server build
          hook = function (context) {
              // 2.3 injection
              context =
                  context || // cached call
                      (this.$vnode && this.$vnode.ssrContext) || // stateful
                      (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
              // 2.2 with runInNewContext: true
              if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                  context = __VUE_SSR_CONTEXT__;
              }
              // inject component styles
              if (style) {
                  style.call(this, createInjectorSSR(context));
              }
              // register component module identifier for async chunk inference
              if (context && context._registeredComponents) {
                  context._registeredComponents.add(moduleIdentifier);
              }
          };
          // used by ssr in case component is cached and beforeCreate
          // never gets called
          options._ssrRegister = hook;
      }
      else if (style) {
          hook = shadowMode
              ? function (context) {
                  style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
              }
              : function (context) {
                  style.call(this, createInjector(context));
              };
      }
      if (hook) {
          if (options.functional) {
              // register for functional component in vue file
              const originalRender = options.render;
              options.render = function renderWithStyleInjection(h, context) {
                  hook.call(context);
                  return originalRender(h, context);
              };
          }
          else {
              // inject component registration as beforeCreate hook
              const existing = options.beforeCreate;
              options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
          }
      }
      return script;
  }

  /* script */
  const __vue_script__$1 = script$1;
  /* template */
  var __vue_render__$1 = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "vcron-select-container" }, [
      _c(
        "span",
        { staticClass: "vcron-select-input", on: { click: _vm.toggleMenu } },
        [
          _vm._t("default", function () {
            return [_vm._v(_vm._s(_vm.selectedStr))]
          }),
        ],
        2
      ),
      _vm._v(" "),
      _c(
        "span",
        { staticClass: "vcron-select-list", style: _vm.listStyle },
        _vm._l(_vm.items, function (item) {
          return _c(
            "span",
            {
              key: item[_vm.itemValue] + "",
              staticClass: "vcron-select-list-item",
              class: {
                "vcron-select-list-item-selected":
                  _vm.selectedItems.includes(item),
              },
              style: _vm.listItemStyle,
              on: {
                click: [
                  function ($event) {
                    return _vm.select(item)
                  },
                  function ($event) {
                    $event.stopPropagation();
                    _vm.multiple ? function () {} : _vm.toggleMenu();
                  },
                ],
              },
            },
            [_vm._v("\n      \n      " + _vm._s(item[_vm.itemText]) + "\n    ")]
          )
        }),
        0
      ),
    ])
  };
  var __vue_staticRenderFns__$1 = [];
  __vue_render__$1._withStripped = true;

    /* style */
    const __vue_inject_styles__$1 = undefined;
    /* scoped */
    const __vue_scope_id__$1 = undefined;
    /* module identifier */
    const __vue_module_identifier__$1 = undefined;
    /* functional template */
    const __vue_is_functional_template__$1 = false;
    /* style inject */
    
    /* style inject SSR */
    
    /* style inject shadow dom */
    

    
    const __vue_component__$1 = /*#__PURE__*/normalizeComponent(
      { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
      __vue_inject_styles__$1,
      __vue_script__$1,
      __vue_scope_id__$1,
      __vue_is_functional_template__$1,
      __vue_module_identifier__$1,
      false,
      undefined,
      undefined,
      undefined
    );

  //

  var script = {
      name: "VueCronEditor",
      components:{
          'CronCore': CronCore__default["default"].component,
          CustomSelect: __vue_component__$1
      },
      props:{
          cols: {
              type: Function,
              default: (fieldId) => {

                  if(fieldId == 'minute') return 5
                  else if (fieldId == 'hour') return 4
                  else if (fieldId == 'day') return 4
                  else return 1
                  
              }
          },
          width: {
              type: Function,
              default: (fieldId) => {
                  if(fieldId == 'minute') return '10em'
                  else if (fieldId == 'hour') return '8em'
                  else if (fieldId == 'day') return '8em'
                  else return 'unset'
              }
          }
      }   
  };

  /* script */
  const __vue_script__ = script;

  /* template */
  var __vue_render__ = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "CronCore",
      _vm._b(
        {
          on: {
            input: function ($event) {
              return _vm.$emit("input", $event)
            },
            error: function ($event) {
              return _vm.$emit("error", $event)
            },
          },
          scopedSlots: _vm._u([
            {
              key: "default",
              fn: function (ref) {
                var fields = ref.fields;
                var period = ref.period;
                return [
                  _c(
                    "span",
                    { staticClass: "vcron-editor" },
                    [
                      _c("span", [_vm._v(_vm._s(period.prefix))]),
                      _vm._v(" "),
                      _c(
                        "custom-select",
                        _vm._g(
                          _vm._b(
                            {
                              attrs: {
                                items: period.items,
                                "item-value": "id",
                                cols: _vm.cols("period"),
                                width: _vm.width("period"),
                              },
                            },
                            "custom-select",
                            period.attrs,
                            false
                          ),
                          period.events
                        )
                      ),
                      _vm._v(" "),
                      _c("span", [_vm._v(_vm._s(period.suffix))]),
                      _vm._v(" "),
                      _vm._l(fields, function (f) {
                        return [
                          _c("span", { key: f.id + "prefix" }, [
                            _vm._v(_vm._s(f.prefix)),
                          ]),
                          _vm._v(" "),
                          _c(
                            "custom-select",
                            _vm._g(
                              _vm._b(
                                {
                                  key: f.id,
                                  attrs: {
                                    items: f.items,
                                    cols: _vm.cols(f.id),
                                    width: _vm.width(f.id),
                                    multiple: "",
                                  },
                                },
                                "custom-select",
                                f.attrs,
                                false
                              ),
                              f.events
                            ),
                            [_vm._v(_vm._s(f.selectedStr))]
                          ),
                          _vm._v(" "),
                          _c("span", { key: f.id + "suffix" }, [
                            _vm._v(_vm._s(f.suffix)),
                          ]),
                        ]
                      }),
                    ],
                    2
                  ),
                ]
              },
            },
          ]),
        },
        "CronCore",
        _vm.$attrs,
        false
      )
    )
  };
  var __vue_staticRenderFns__ = [];
  __vue_render__._withStripped = true;

    /* style */
    const __vue_inject_styles__ = undefined;
    /* scoped */
    const __vue_scope_id__ = undefined;
    /* module identifier */
    const __vue_module_identifier__ = undefined;
    /* functional template */
    const __vue_is_functional_template__ = false;
    /* style inject */
    
    /* style inject SSR */
    
    /* style inject shadow dom */
    

    
    const __vue_component__ = /*#__PURE__*/normalizeComponent(
      { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
      __vue_inject_styles__,
      __vue_script__,
      __vue_scope_id__,
      __vue_is_functional_template__,
      __vue_module_identifier__,
      false,
      undefined,
      undefined,
      undefined
    );

  // Import vue component

  // Declare install function executed by Vue.use()
  function install(Vue) {
  	if (install.installed) return;
  	install.installed = true;
  	Vue.component('CronLight', __vue_component__);
  }

  // Create module definition for Vue.use()
  const plugin = {
  	install,
  	component: __vue_component__,
  	util: CronCore__default["default"].util
  };

  exports["default"] = plugin;
  exports.install = install;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
